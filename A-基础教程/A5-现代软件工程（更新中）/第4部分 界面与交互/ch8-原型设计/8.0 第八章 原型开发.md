
技术选型
原型实现
工作量估计
项目计划

- [1] http://www.zhoujingen.cn/blog/5610.html
- [2] 低保真原型与高保真原型，https://www.jianshu.com/p/c1fa72cb4021

- [3] Prototyping Model，https://ecomputernotes.com/software-engineering/explain-prototyping-model

prototype

MVP



 
水平和垂直的原型

我们和业务人员经常谈到的是水平原型，水平原型也叫做“行为原型” (behavioral prototype)。探索预期系统的一些特定行为，并达到细化需求的目的。当用户在考虑原型中所提出的功能可否使他们完成各自的业务任务时，原型使用户所探讨的问题更加具体化。它更多从业务需求着手，应用在需求阶段。

垂直原型（vertical prototype），也叫做结构化原型或概念的证明，实现了一部分应用功能。当预期实现阶段可能存在技术风险时，可以开发一个垂直原型。垂直原型通常用在生产运行环境中的生产工具构造，使其结果一目了然（更有意义）。比起在软件的需求开发阶段，垂直原型更常用于软件的设计阶段以减少风险。

抛弃型原型或进化型原型

从原型存在生命时机考虑分为抛弃型原型和进行型原型，抛弃型原型不作为最终产品的一部分，只是作为探索性的回答一些需求问题，细化需求并提高需求质量。由于在开发阶段最终将抛弃这些原型，因此不需要花太大力气去建立该原型。

进化型原型是在已经清楚地定义了需求的情况下，为开发渐进式产品提供了坚实的开发基础，作为产品的部分实现。与抛弃型原型的快速、粗略的特点相比，进化式模型一开始就必须具有健壮性和产品质量级的代码。因此，对于描述相同的功能，建立进化型原型比建立抛弃型原型所花的时间要多。一个进化型原型必须设计为易于升级和优化的，因此，你必须重视软件系统性和完整性的设计原则。要达到进化型原型的质量要求并没有捷径。进化型原型一般在处理架构时会采用。

低保真原型和高保真原型

原型分低保真原型和高保真原型，低保真原型目标在于表达工作主要内容，体现静态的元素，不需要动态交互。高保真原型目标是作出一个和实际上线后的产品差不多的样子，不仅包括静态的界面，还包括交互，甚至有的还把数据保存、逻辑验证等都包含在内。如果客户要求开发之前必须看到和实际产品一样的原型时，这时就需要做高保真原型，如果对于小型项目，或者只是用来做交流主要需求用时，就可以做低保真原型。

原型工具

需求在产品开发中的重要性已经是不需争议的事实，现在需求方法有很多， 业界最常用的一种办法就是通过原型展现需求，通过用例表达需求。业务人员掌握制作原型能够更快更清楚的表达业务，同客户和开发可以进行更直观的沟通，使得大家在理解上容易更一致。然而原型工具有非常多，比如大多数人用过的Excel、Access、Delphi、PowerPoint、Axure、Balsamiq Mockups、ForeUI、iRise、Lucid Spec、Mockup Screens、Pencil、Serena等，甚至开发工具雅奇等也可以用来做原型。工欲善其事，必先利其器，对于刚刚使用原型方法的业务人员来说，如何选择适合自己的原型工具呢？这就需要首先根据原型的目的明确做原型的粒度。

在限定时间内能够将需求表达更清晰需要一个合适的工具。业务人员一般都不会有什么编程经验，我们怎么能够做出表达静态元素界面，又能加入动态交互功能的原型呢？为了能在需求阶段都能够更好的采用原型开发方法，我搜集并使用过多种原型工具，希望找打一款比较使用简单，但又能实现一般的交互功能，最好是业务人员学个一个小时就可以完全自己动手使用了。我用过一个原型工具 GUI Design Studio ，它的主要特点就是操作简单，不需要开发人员帮助，通过半个小时的学习后你将可以自己开始做原型了。《原型工具GUI Design Studio》对这个工具的使用进行可简单介绍。

原型不仅仅是界面

我们可以通过原型来引导用户来使用系统解决问题，但原型不仅仅是需求，它还是设计、开发工具，所以作原型时不仅需要客户的参与，也需要技术人员的参与，但应该尽量由业务人员而非开发人员来实现原型的需求部分。下面是在UCD社区里面看到的一张图，原型最主要功能是表现界面，但要做好界面其实不容易，山下面还有很多东西需要考虑才能支撑界面，其实做原型的过程就是设计系统的过程。我们都希望尽量把开发工作前移，需求能做的工作就不留到开发环节做。如果软件模式一定，那么框架做得好的话就一定可以让业务人员来做一部分现在属于开发人员的工作（注：这部分工作其实本就该属于业务人员），那时大家就能体会到开发软件就如同做原型一样的乐趣了！

使用原型有三个主要目的：


OEA的原型工具将会考虑集成需求工具、设计工具和开发工具与一体，由业务需求人员、设计师和开发人员在OpenExpressApp平台下进行连贯的开发，它做的是水平、进化型、高保真原型。


- Prototyping Style: This addresses the various
approaches to developing prototypes. Prototypes can be developed as throwaway code
or paper products, as an evolution of a working design, or as an executable specification.

Different prototyping life cycle processes are
typically used for each style. The style chosen is based on the type of results the project
needs, the quality of the results needed, and
the urgency of the results.

- Prototyping Target: The target of the prototype activity is the specific product being
served by the prototyping effort. Examples
of prototyping targets include a requirements
specification, an architectural design element
or component, an algorithm, or a humanmachine user interface.

- Prototyping Evaluation Techniques: A prototype may be used or evaluated in a number of ways by the software engineer or
other project stakeholders, driven primarily
by the underlying reasons that led to prototype development in the first place. Prototypes may be evaluated or tested against
the actual implemented software or against 
Software Engineering Models and Methods 9-9
a target set of requirements (for example, a
requirements prototype); the prototype may
also serve as a model for a future software
development effort (for example, as in a user
interface specification).



6.2. Prototyping
Prototyping is commonly a means for validating
the software engineer’s interpretation of the software requirements, as well as for eliciting new
requirements. As with elicitation, there is a range
of prototyping techniques and a number of points
in the process where prototype validation may
be appropriate. The advantage of prototypes is
that they can make it easier to interpret the software engineer’s assumptions and, where needed,
give useful feedback on why they are wrong. For
example, the dynamic behavior of a user interface can be better understood through an animated prototype than through textual description
or graphical models. The volatility of a requirement that is defined after prototyping has been
done is extremely low because there is agreement
between the stakeholder and the software engineer—therefore, for safety-critical and crucial
features prototyping would really help. There are
also disadvantages, however. These include the
danger of users’ attention being distracted from
the core underlying functionality by cosmetic
issues or quality problems with the prototype. For
this reason, some advocate prototypes that avoid
software, such as flip-chart-based mockups. Prototypes may be costly to develop. However, if
they avoid the wastage of resources caused by
trying to satisfy erroneous requirements, their
cost can be more easily justified. Early prototypes may contain aspects of the final solution.
Prototypes may be evolutionary as opposed to
throwaway.