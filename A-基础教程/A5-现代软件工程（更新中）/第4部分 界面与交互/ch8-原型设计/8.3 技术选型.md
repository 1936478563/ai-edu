# 8.3 技术选型

技术选型
原型实现

## 8.3.1 项目的故事

木头参与的一个真实项目，虽然不怎么大，但是麻雀虽小五脏俱全，面向客户的系统，无论规模如何，都要全力以赴，谨慎对待。

- 某基金客户想使用热门的深度学习来预测 A 股股票行情走向，所以找到了 MSRA 请求合作。客户将会在每周末上传上一周的股票交易数据，在微软 Azure 上完成存储、处理、预测、输出等一系列过程，然后从 Azure 上下载预测结果。

- 我软的研究员们深入研究了几个月，他们根据股票交易历史数据，在 Azure 上训练了一系列基于神经网络的深度学习模型，存入模型库中。

- 我软的工程师们，会监控客户的上传数据动作，一旦上传结束后，立刻在 Azure 上启动预测流程，调用研究员的模型库，根据最新交易结果进行预测，得到预测结果后，通知客户下载。

## 8.3.2 需求分析初步

我们根据上面的需求描述，把每个参与者（用户、研究员、工程师）的数据流图单独画出来，这样可以避免一开始就陷入复杂的逻辑纠缠中。

图 8.3.1 的独立数据流图描述了需求分析的结果。

<div align="center">
<img src="Images/Slide12.JPG"/>
图 8.3.1 - 独立数据流图
</div>

### 研究员数据流图

流程：

1. 研究员在自己的计算机上设计模型，并提交训练代码到云端存储；
2. 云端有一个代码存储库（蓝色部分），包括模型、代码、初始参数等；
3. 研究员登录到云端服务器，启动训练过程；
4. 在训练开始时，需要读取存储在云端的股票历史数据（浅绿色部分）；
5. 训练结束后，把成熟的模型存放到模型库（黄色部分），供预测使用。

对研究员来说，“提交训练代码”和“训练”是两个主要动作，需要写代码实现，还要看应该部署在什么设备上运行；其它的一些辅助存储需要确定使用 Azure 上的什么存储设备。

### 用户数据流图

流程：

1. 用户上传数据到云端的数据存储上；
2. 用户得到通知后，下载预测结果文件。

对用户来说比较简单，就是两个动作：上传、下载，后面的一切流程都是透明的。所以，我们需要设计“上传”和“下载”的实现。

### 工程师数据流图

流程：

1. 开发完毕后，提交预测代码到云端部署（蓝色部分）；
2. 启动预测过程；
3. 在预测开始前，要读取股票历史数据和最新上传的数据（浅绿色部分），还要从模型库（黄色部分）中读取最新模型；
4. 预测完毕后，输出结果文件（绿色部分），并通知用户去下载。

对于工程师来说，“提交预测代码”和“预测”是两个主要动作，需要写代码实现，还要看应该部署在什么设备上运行；其它的一些辅助存储需要确定使用 Azure 上的什么存储设备。

## 8.3.3 集成

下面我们需要把三个独立的数据流图合并成一个完整的数据流图，来发现需要改进的地方。如图 8.3.2 所示。

<div align="center">
<img src="Images/Slide13.JPG"/>
图 8.3.2 - 整体数据流图
</div>

合并的过程很简单，把图 8.3.1 中重复（具有相同名字并且相同颜色）的单元删掉，但是保留连接线。比如“数据存储”单元一共有三个，删掉右侧的两个，然后把“上传文件”连接到左侧的“数据存储”上，再把“预测”连接到左侧的“数据存储”上，箭头方向保持不变。

如此重复，去掉所有重名重色的单元后，再调整各个单元的位置，尽量让连接线没有交叉，就变成了图 8.3.2 的样子。当然，由于这是一个拓扑图，所以可能画法不止一种。

与图 8.3.1 不同的是，这里多了一个深色的矩形区域“Azure”，表明在我们的设计中，矩形区域内的元素，包括数据、行为、流程，都应该使用 Azure 提供的技术。

接下来我们仔细看一下整体数据流图：“上传文件”是一个动作（或者可执行程序），文件存储到“数据存储”单元后，如何触发“训练”和“预测”的动作发生呢？

激活一个程序，有四种方式：

1. 人工手动启动程序
  
   肯定不能是1，因为周末非工作时段的不一定保证能及时响应。 

2. 定时启动；

   也不能是2，因为不知道用户何时上传数据，如果正上传一半时启动程序，就会出错。无论怎样设置定时器，都有可能发生这种情况。

3. 由特殊事件触发
   
   因为文件存储系统都会检测到文件变化，然后发出一个事件，我们只要监听这个事件就行了。

4. 其它程序调用

   那么就需要我们再编制一个“主控程序”，这样会多出一些工作来。所以我们先看看3如何实现。

<div align="center">
<img src="Images/Slide14.JPG"/>
图 8.3.3 - 原型开发流程
</div>

图 8.3.3 描述了上面所述的分析，我们统一称之为“通知机制”，即，如何通知一个程序启动。其中的1和4，表示在上传文件结束时，通知训练或者预测启动；2和3，表示被文件存储系统的变化事件激活；5表示在预测完毕后，如何通知用户下载文件。

## 8.3.4 技术选型

在 Azure 上有很多存储技术可以选用，但是由于用户每次上传的不是一个文件，而是多个，所以每一个文件都会触发一次文件变化通知，那么我们如何知道哪个通知是最后一个呢？也许用户上传了3个文件，喝了杯咖啡，然后又上传了2个文件。或者是上周有5个交易日，一共5个文件；本周只有3个交易日，所以只有3个文件。

当时木头在做这个选择时，与大家讨论了多次，其中一个Dev Lead 认为我们应该在服务器端维护一套完美的逻辑，能够判断出“用户上传文件是否结束了”。但是，木头想来想去都觉得这是不可能完成的任务，总会有意外发生，不可能完美。最后的推论是：
1. 只有用户自己知道何时上传完了所有文件！
2. 这种不确定性不能在服务器端解决！！

所以，我们会考虑图 8.3.3 中的1和4路径，而删除2和3路径。

但是新问题又来了：上传文件行为是在客户端发生的，远在 Azure 之外，它不可能“调用”部署在 Azure 上的“训练”和“预测”模块，它只能“通知”。考虑到“训练”和“预测”模块的独立性，我们尽量不要改它们的业务逻辑，而是在外面单独增加一个控制中心，来接收来自客户端的“通知”，再做后续处理。

<div align="center">
<img src="Images/Slide15.JPG"/>
图 8.3.4 - 原型开发流程
</div>

如图 8.3.4 所示的流程：
1. 上传文件结束后通知“控制中心”，这也避免了客户端程序直接接触到系统的核心功能，需要的话，在控制中心可以做各种保护措施；
2. 控制中心调度，执行训练；
3. 然后执行预测；
4. 然后通知用户。

这种中心化的设计在系统设计中是很常见的。